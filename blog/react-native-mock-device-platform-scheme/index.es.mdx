---
title: 'React Native & Jest: Hacer un mock del dispositivo y del tema actual '
description: Probando el c√≥digo como dispositivo iOS, iPad o Android. Modo claro y modo oscuro.
date: 2022-12-02
image: ../../src/images/blog/mobile-device-ios.jpg
imageAlt: Photo by Omid Armin on Unsplash
published: true
tags: ['reactnative', 'typescript', 'javascript', 'react', 'jest', 'mock']
---

# React Native & Jest: Hacer un mock del dispositivo y del tema actual

Cuando tienes una aplicaci√≥n React Native y quieres testear algunos componentes. Probablemente tarde o temprano tendr√°s la necesidad de renderizar esos componentes desde un dispositivo iOS, iPad o Android.

La parte dif√≠cil no es agregar soporte para el dispositivo, eso viene por defecto en el framework. La parte complicada es decirle al framework de testing como quieres renderizar a ese componente.

A continuaci√≥n voy a listar las soluciones que encontr√© en el proceso de agregar esos tests.

## üî® ¬øQu√© librer√≠as estoy usando?

Para el siguiente tutorial, estoy utilizando:

- React: 18
- React Native: 0.70.2
- Jest: 29.1
- Typescript: 4.8
- `@testing-library/react-native` : 11.2.0 (para hacer testing de componentes JSX)

## üíª¬†Haciendo un mock del dispositivo

### Detectando el sistema operativo con una funci√≥n Helper

Como sabr√°s, debemos utilizar `Platform.OS` para detectar desde que plataforma estamos ejecutando nuestro c√≥digo. Para hacer m√°s f√°cil de probar y / o reutilizar el c√≥digo en diversos lugares de nuestro proyecto, prefiero tener un archivo ‚ÄúHelper‚Äù. En el siguiente ejemplo voy a utilizar la sintaxis de ESM pero, por supuesto, puedes utilizar la de CommonJS.

Agreguemos un m√©todo est√°tico para evitar inicializar la clase. En lugar de `new Helpers().isIpad()` , podemos utilizar `Helpers.isIpad()` simplemente.

```tsx
import { Platform } from 'react-native';

export default class Helpers {
  static isIpad(): boolean {
    const devicePlatform = Platform;
    if (devicePlatform.OS !== 'ios') {
      return false;
    }

    return devicePlatform.isPad ?? false;
  }
}
```

### Escribiendo los tests

Vamos a probar que nuestra funci√≥n puede correr sobre Android

```tsx
import { Platform } from 'react-native';

it('comprobar si isIpad retorna falso si el dispositivo es Android', () => {
  Platform.OS = 'android';
  const isIpadDefault = Helpers.isIpad();
  expect(isIpadDefault).toBe(false);
});
```

Como puedes ver, utilizamos `Platform.OS`para sobrescribir nuestra plataforma por cada test.

```tsx
// Typescript
jest.spyOn(Platform as PlatformIOSStatic, 'isPad', 'get').mockReturnValueOnce(true);
// Javascript
jest.spyOn(Platform, 'isPad', 'get').mockReturnValueOnce(true);
```

Por cierto, un dispositivo iPad ser√° tratado como un dispositivo `ios`. Entonces, ¬øc√≥mo podemos forzar a React Native para siempre retornar `true`en la funci√≥n `Platform.isIpad()`?

Ac√° es donde los _spies de Jest_ vienen en nuestra ayuda. Ya que `isIpad`es una funci√≥n _getter,_ con los spies, hay una manera f√°cil de sobrescribirla. Utilizo `mockReturnValueOnce`para especificar el retorno de la funci√≥n la primera vez que es ejecutada.

> En espa√±ol, `mockReturnValueOnce`, se traducir√≠a a algo como `hacerMockRetornarUnaSolaVez`

Para Typescript utilizaremos `PlatformIOSStatic`, esta es una manera de decirle a TS que los tipos de `Platform` se refieren a un dispositivo iOS y iPad.

Una vez aprendido eso. Podemos comenzar a agregar tests para cubrir cualquier caso raro.

```tsx
import { Platform } from 'react-native';
import type { PlatformIOSStatic } from 'react-native';

it('comprobar si isIpad retorna falso si el dispositivo es Android', () => {
  Platform.OS = 'android';
  const isIpadDefault = Helpers.isIpad();
  expect(isIpadDefault).toBe(false);
});

// Validaci√≥n de casos pocos comunes
it('comprobar si isIpad retorna falso si dispositivo es iOS y iPad retorna undefined', () => {
  Platform.OS = 'ios';
  jest.spyOn(Platform as PlatformIOSStatic, 'isPad', 'get').mockReturnValueOnce(undefined);
  const isIpadDefault = Helpers.isIpad();
  expect(isIpadDefault).toBe(false);
});

it('comprobar si isIpad retorna falso si dispositivo es iOS pero no iPad', () => {
  Platform.OS = 'ios';
  jest.spyOn(Platform as PlatformIOSStatic, 'isPad', 'get').mockReturnValueOnce(false);
  const isIpadDefault = Helpers.isIpad();
  expect(isIpadDefault).toBe(false);
});

it('comprobar si isIpad retorna verdadero si dispositivo es iOS y iPad', () => {
  Platform.OS = 'ios';
  jest.spyOn(Platform as PlatformIOSStatic, 'isPad', 'get').mockReturnValueOnce(true);
  const isIpadDefault = Helpers.isIpad();
  expect(isIpadDefault).toBe(true);
});
```

### Contaminaci√≥n de tests

Ya que algunos tests pueden ejecutarse en paralelo. Podr√≠amos tener una poluci√≥n de tests. Significa que algunos valores de un test pueden influir en otros del mismo grupo. ¬øPuedes ver c√≥mo cada uno tiene un `Platform.OS = 'ios'` ?. Si quieres poner una plataforma por defecto, puedes encerrar tus tests dentro de una funci√≥n `describe` y despu√©s agregar un `afterEach` . Con esto, podemos sobrescribirla y devolverla al estado inicial despu√©s de cada test.

```tsx
describe('Funci√≥n con tests', () => {
  afterEach(() => {
    Platform.OS = 'ios';
  });

  // ... Ac√° puedes colocar todos tus tests
});
```

## üé®¬†Hacer un mock del hook useColorScheme

Listo, ahora podemos sobrescribir la plataforma. Pero ¬øqu√© hay del modo oscuro?. Ya sea que est√©s usando Android o iOS, el modo oscuro ser√° √∫til especialmente durante las noches o en entornos oscuros. Desde React Native, podemos codificar unas condiciones para estilos basados en √©l. Y tenemos acceso a `useColorScheme` . ¬øC√≥mo podemos hacerle un mock?

Primero, veamos un ejemplo de c√≥mo se utiliza el hook para implementar el modo oscuro en un componente.

### Mi componente ColoredStatusBar (Barra de Estado Coloreada)

Esta funci√≥n cambia el color de la barra de estado validando si el Sistema Operativo es `ios` y si est√° en modo claro. El archivo `GlobalStyles` contiene declaraciones de los [estilos de React Native](https://reactnative.dev/docs/style) como objetos. El hook `useIsFocused` viene desde [React Navigation](https://reactnavigation.org/docs/use-is-focused/) para detectar si la aplicaci√≥n se encuentra ‚Äúenfocada‚Äù (activa).

```tsx
import React from 'react';
import { StatusBar, StatusBarProps, useColorScheme } from 'react-native';
import { useIsFocused } from '@react-navigation/native';
import EstilosGlobales from '../constants/GlobalStyles';
import Helpers from '../services/Helpers';

export default function ColoredStatusBar(props: StatusBarProps) {
  // üá™üá∏ Para facilitar el entendimiento las variables est√°n traducidas
  const appEstaActiva = useIsFocused();
  const tema = useColorScheme();
  const dispositivoSO = Helpers.getOS();

  const color =
    dispositivoSO === 'ios' && tema === 'light'
      ? EstilosGlobales.headerStyle.backgroundColor
      : EstilosGlobales.headerStyleDark.backgroundColor;

  return appEstaActiva ? <StatusBar backgroundColor={color} {...props} /> : null;
}
```

### Implementaci√≥n actual del hook

Si vamos al c√≥digo fuente de `useColorScheme` nos encontraremos lo siguiente. Este es c√≥digo de React Native de la versi√≥n mencionada antes.

```tsx
import { useSyncExternalStore } from 'use-sync-external-store/shim';
import Appearance from './Appearance';
import type { ColorSchemeName } from './NativeAppearance';

export default function useColorScheme(): ?ColorSchemeName {
  return useSyncExternalStore(
    (callback) => {
      const appearanceSubscription = Appearance.addChangeListener(callback);
      return () => appearanceSubscription.remove();
    },
    () => Appearance.getColorScheme(),
  );
}
```

Est√°n utilizando un `export` del tipo ESM para exportar una funci√≥n por defecto. Hacerle un mock ser√° un poco diferente.

Veamos como podemos hacer un [test snapshot](https://jestjs.io/docs/snapshot-testing) al componente.

### Creando un test si el dispositivo es iPad y en modo oscuro

```tsx
it('se renderiza para iOS y el tema es oscuro', () => {
  Platform.OS = 'ios';
  jest.doMock('react-native/Libraries/Utilities/useColorScheme', () => ({
    default: jest.fn().mockReturnValueOnce('dark'),
  }));
  (useIsFocused as jest.Mock).mockReturnValue(true);
  const { toJSON } = render(<ColoredStatusBar />);

  expect(useIsFocused).toHaveBeenCalledTimes(1);
  expect(toJSON()).toMatchSnapshot();
});
```

Algunas notas aqu√≠

- Usamos ac√° `doMock` para evitar la poluci√≥n de tests. Lee la documentaci√≥n [aqu√≠](https://jestjs.io/docs/jest-object#jestdomockmodulename-factory-options). Y retornamos `dark` a la primera llamada, porque si no lo hacemos, regresar√° `light` por defecto.
- Estamos comprobando tambi√©n que el hook `useIsFocused` es llamado al menos una vez (primer render)
- Usamos `toJSON` para hacer un _test snapshot_ del componente.
