---
title: 'React Native: Faire un mock dâ€™un appareil et du thÃ¨me'
description: Test du code en tant qu'appareil iOS, iPad et Android. Mode clair et mode sombre
date: 2022-12-02
image: ../../src/images/blog/mobile-device-ios.jpg
imageAlt: Photo by Omid Armin on Unsplash
published: true
tags: ['reactnative', 'react', 'typescript', 'javascript', 'react', 'jest', 'mock']
---

# React Native: Faire un mock dâ€™un appareil et du thÃ¨me

Si tu as une application React Native et tu veux tester quelques composants. TÃ´t ou tard, tu auras besoin de _render_ ces composants dans un appareil iOS, iPad ou Android.

Lâ€™Ã©tage, le plus difficile, ce nâ€™est pas dâ€™ajouter de support pour lâ€™appareil, Ã§a vient par dÃ©faut. Câ€™est de dire au composant comment tu en veux rendre.

Ensuite, je vais lister les solutions que jâ€™ai trouvÃ©es au processus dâ€™ajouter ces tests.

## ðŸ”¨Â Quels plugiciels jâ€™utilise?

Pour le tutoriel prochain, jâ€™utilise:

- React: 18
- React Native: 0.70.2
- Jest: 29.1
- Typescript: 4.8
- `@testing-library/react-native` : 11.2.0 (pour faire de testing sur les composants JSX)

## ðŸ’»Â Faire un mock de lâ€™appareil

### Comment dÃ©tecter le systÃ¨me dâ€™exploitation dans une fonction Helper

Comme tu le sais, on doit utiliser `Platform.OS` pour dÃ©tecter dÃ¨s quoi plateforme on exÃ©cute le code. Pour le faire plus facile de le tester ou rÃ©utiliser le code aux multiples lieus dans notre code, je prÃ©fÃ¨re avoir un fichier â€œHelperâ€. Dans lâ€™exemple prochain, je vais utiliser la syntaxe ESM, mÃªme si tu en peux faire avec CommonJS.

Ajoutons une mÃ©thode statique pour Ã©viter dâ€™initialiser la classe. PlutÃ´t quâ€™utiliser `new Helpers().isIpad()` , ce mieux Ã©crire `Helpers.isIpad()`

```tsx
import { Platform } from 'react-native';

export default class Helpers {
  static isIpad(): boolean {
    const devicePlatform = Platform;
    if (devicePlatform.OS !== 'ios') {
      return false;
    }

    return devicePlatform.isPad ?? false;
  }
}
```

### Ã‰crire les tests

On y va tester notre fonction qui sâ€™execute sur Android

```tsx
import { Platform } from 'react-native';

it("tester si isIpad retourne faux quand l'appareil est Android", () => {
  Platform.OS = 'android';
  const isIpadDefault = Helpers.isIpad();
  expect(isIpadDefault).toBe(false);
});
```

On utilise `Platform.OS` pour replacer la plateforme par chaque test.

```tsx
// Typescript
jest.spyOn(Platform as PlatformIOSStatic, 'isPad', 'get').mockReturnValueOnce(true);
// Javascript
jest.spyOn(Platform, 'isPad', 'get').mockReturnValueOnce(true);
```

Dâ€™ailleurs, un appareil iPad serait considÃ©rÃ© comme `iOS` . Alors, comment pouvons-nous forcer toujours React Native pour retourner `true` dans sa fonction `Platform.isIpad()`?

Et voilÃ  les _spies_ de Jest nos aident. MÃªme si `isIpad`est une fonction _getter_ on peut le replacer. Jâ€™utilise `mockReturnValueOnce`pour spÃ©cifier le retour de la fonction la premiÃ¨re fois qui est exÃ©cutÃ©.

> En franÃ§ais, `mockReturnValueOnce`, serait traduit par `faireMockRetournerUneFois`

Pour Typescript, on ajoute `PlatformIOSStatic`, câ€™est une faÃ§on de dire en TS que les _types_ de `Platform` se rÃ©fÃ¨rent aux appareils iOS et iPad.

Donc, on peut commencer Ã  ajouter des tests pour traiter quelque cas Ã©trange.

```tsx
import { Platform } from 'react-native';
import type { PlatformIOSStatic } from 'react-native';

it("tester si isIpad retourne faux si l'appareil est Android", () => {
  Platform.OS = 'android';
  const isIpadDefault = Helpers.isIpad();
  expect(isIpadDefault).toBe(false);
});

it("tester si isIpad retourne faux si l'appareil est iOS et si iPad retourne undefined", () => {
  Platform.OS = 'ios';
  jest.spyOn(Platform as PlatformIOSStatic, 'isPad', 'get').mockReturnValueOnce(undefined);
  const isIpadDefault = Helpers.isIpad();
  expect(isIpadDefault).toBe(false);
});

it("tester si isIpad retourne faux si l'appareil est iOS mais pas un iPad", () => {
  Platform.OS = 'ios';
  jest.spyOn(Platform as PlatformIOSStatic, 'isPad', 'get').mockReturnValueOnce(false);
  const isIpadDefault = Helpers.isIpad();
  expect(isIpadDefault).toBe(false);
});

it("tester si isIpad retourne vrai si l'appareil est iOS et iPad", () => {
  Platform.OS = 'ios';
  jest.spyOn(Platform as PlatformIOSStatic, 'isPad', 'get').mockReturnValueOnce(true);
  const isIpadDefault = Helpers.isIpad();
  expect(isIpadDefault).toBe(true);
});
```

### La pollution des tests

## ðŸŽ¨Â Faire un mock du hook useColorScheme

Puisque quelques composants sâ€™exÃ©cutent au parallÃ¨le. On pourrait avoir des pollutions de tests. Ã‡a signifie que les valeurs dâ€™un test peuvent influer dans les autres au mÃªme groupe. Peux-tu voir que chaque test a `Platform.OS = 'ios'` ? Si tu veux fixer une plateforme par dÃ©faut, enferme les tests dans la fonction `describe` et ajouter un `afterEach`. Avec Ã§a, on peut la substituer et la retourner Ã  lâ€™Ã©tat initial aprÃ¨s les tests.

```tsx
describe('Fonction avec tests', () => {
  afterEach(() => {
    Platform.OS = 'ios';
  });

  // ... Voici tu peux mettre tous les tests
});
```

### Mon composant ColoredStatusBar

Cette fonction change la couleur de la barre dâ€™Ã©tat au validant si le systÃ¨me dâ€™exploitation est `ios` y si est sur le mode clair. Le fichier `GlobalStyles` contient les dÃ©clarations du style de React Native comme objets. Le hook `useIsFocused` vient de React Navigation pour detecter si lâ€™application est active sur lâ€™Ã©cran.

```tsx
import React from 'react';
import { StatusBar, StatusBarProps, useColorScheme } from 'react-native';
import { useIsFocused } from '@react-navigation/native';
import StylesGlobaux from '../constants/GlobalStyles';
import Helpers from '../services/Helpers';

export default function ColoredStatusBar(props: StatusBarProps) {
  // ðŸ‡«ðŸ‡· Pour faciliter la comprÃ©hension les variables sont traduites
  const appEstActive = useIsFocused();
  const theme = useColorScheme();
  const appareilSystemeExpl = Helpers.getOS();

  const couleur =
    appareilSystemeExpl === 'ios' && theme === 'light'
      ? StylesGlobaux.headerStyle.backgroundColor
      : StylesGlobaux.headerStyleDark.backgroundColor;

  return appEstActive ? <StatusBar backgroundColor={couleur} {...props} /> : null;
}
```

### Lâ€™implÃ©mentation actuelle du hook

Si on va au code source de `useColorScheme` , on peut trouver le code suivant. Câ€™est le code de React Native.

```tsx
import { useSyncExternalStore } from 'use-sync-external-store/shim';
import Appearance from './Appearance';
import type { ColorSchemeName } from './NativeAppearance';

export default function useColorScheme(): ?ColorSchemeName {
  return useSyncExternalStore(
    (callback) => {
      const appearanceSubscription = Appearance.addChangeListener(callback);
      return () => appearanceSubscription.remove();
    },
    () => Appearance.getColorScheme(),
  );
}
```

Ils sont utilisÃ©s `export` de type ESM pour exporter une fonction par dÃ©faut. Pour se devenir un mock, Ã§a change un peu.

Donc, comment peut-on faire un [test snapshot](https://jestjs.io/docs/snapshot-testing) au composant?

### CrÃ©er un test si lâ€™appareil est iPad et en mode sombre

```tsx
it('se rend pour iOS et le thÃ¨me est mode sombre', () => {
  Platform.OS = 'ios';
  jest.doMock('react-native/Libraries/Utilities/useColorScheme', () => ({
    default: jest.fn().mockReturnValueOnce('dark'),
  }));
  (useIsFocused as jest.Mock).mockReturnValue(true);
  const { toJSON } = render(<ColoredStatusBar />);

  expect(useIsFocused).toHaveBeenCalledTimes(1);
  expect(toJSON()).toMatchSnapshot();
});
```

Ceci quelques notes:

- On utilise `doMock` pour Ã©viter ter la pollution de tests. Lire la documentation [ici](https://jestjs.io/docs/jest-object#jestdomockmodulename-factory-options). Et on retourne `dark` au premier appel, parce que si on ne le fait pas, Ã§a va retourner `light` par dÃ©faut.
- On teste aussi si le hook `useIsFocused` est appelÃ© au moins une fois
- On utilise `toJSON` pour faire un _test snapshot_ sur mon composant.
