---
title: 'Faire un mock pour une variable globale dans les tests de Python'
description: Jâ€™ai essayÃ© de tester quelques variables globales dans Python, spÃ©cialement pour un script, qui contient des variables globales. Et aprÃ¨s avoir essayÃ© et essayÃ© (et Ã©chouer), je pense que je peux te comment le faire.
date: 2022-05-13
published: true
image: ../../src/images/blog/python-global-envs.jpg
---

Jâ€™ai essayÃ© de tester quelques variables globales dans Python, spÃ©cialement pour un script, qui contient des variables globales. Et aprÃ¨s avoir essayÃ© et essayÃ© (et Ã©chouer), je pense que je peux te comment le faire.

## ğŸƒÂ La solution la plus rapide

```python
# fichier_demo.py
ENVS = { 'vraie_valeur': True, 'autre_vraie_valeur': False }

# test_fichier_demo.py
mocker.patch("fichier_demo.ENVS", new={'MOCKED_NONE': None, 'MOCKED_VIDE': ''})
```

Ensuite, dans ton `fichier_demo` , la variable ENVS sera comme _mocked._

## âœï¸Â La solution avec des descriptions

### ğŸ“”Â Conditions

Pour faciliter le travail, je vais recommander lâ€™outil suivant: [https://pypi.org/project/pytest-mock/](https://pypi.org/project/pytest-mock/)

### ğŸ¤”Â Quâ€™est-ce que je voulais faire?

Tout dâ€™abord, nous avons un fichier appelÃ© `fichier_demo.py` avec le contenu suivant (et oÃ¹ est la variable globale).

```python
# fichier_demo.py
import os

ENVS = { 'vraie_valeur': os.environ('VRAIE_VALEUR'), 'autre_vraie_valeur': os.environ('VRAIE_VALEUR') }

def fonction_simple():
		print(ENVS)
		return 0
```

Si tu essayes dâ€™Ã©xecuter `fonction_simple` , elle montrera le dictionnaire avec `vraie_valeur`et `autre_vraie_valeur` lÃ .

Maintenant, nous avons le fichier suivant de test

```python
# tester_mes_envs.py
from fichier_demo import fonction_simple

def tester_si_fonction_simple_fonctionne():
		assert fonction_simple() == 0
```

Voyons, je sais que le test semble simple, mais il sâ€™assure de retourner une valeur zÃ©ro aprÃ¨s montrer les valeurs ENVs.

### ğŸ‘¾ Ã‰crasement et simulation (se moquer) des variables

Comme tu peux le voire, on appelle les variables dâ€™environnement qui vient de lâ€™ordinateur quâ€™on utilise, et si tu Ã©crire tes tests, on espÃ¨re les avoir dans le serveur CI/CD, ensuite les tests commenceront Ã  Ã©chouer. Comment pouvons-nous Ã©viter Ã§a et utiliser des valeurs fixÃ©es dans notre serveur de tests (ou pipeline).

Si tu as installÃ© lâ€™outil mentionnÃ© ci-dessus, dans la section de Conditions, il est trÃ¨s facile de commencer de se moquer des valeurs. On a donc juste besoin dâ€™ajouter une seule ligne.

```python
# tester_mes_envs.py
from fichier_demo import fonction_simple

@mocker.patch("fichier_demo.ENVS", new={'VRAIE_VALEUR_MOCKED': None, 'AUTRE_VRAIE_VALEUR_MOCKED': ''})
def tester_si_fonction_simple_fonctionne():
		assert fonction_simple() == 0
```

Et tes tests nâ€™exÃ©cuteront pas la variable `ENV` vraie, et par consÃ©quent, ils nâ€™appelleront pas `os.environ`.
