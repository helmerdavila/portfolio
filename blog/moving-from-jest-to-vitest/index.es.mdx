---
title: 'Migr√© de Jest a Vitest en menos de 3 horas'
description:
date: 2023-02-14
published: true
image: ../../src/images/blog/moved-from-jest.png
imageAlt: 'Migrando desde jest'
tags: ['react', 'jest', 'vitest', 'testing', 'typescript', 'gatsby']
---

# Migr√© de Jest a Vitest en menos de 3 horas

## ü§î ¬øPor qu√©?

Hab√≠a le√≠do de los m√∫ltiples beneficios de Vitest, como velocidad, facilidad para migrar desde Jest y no necesitar de una configuraci√≥n compleja para integrar Typescript.

As√≠ que, calcul√© una migraci√≥n de mi stack de pruebas en unas 6 horas, y me tom√≥ s√≥lo 3. Para ser honesto, pudo haber sido incluso menos, todo depende de tu velocidad al escribir c√≥digo, complejidad del proyecto y c√≥mo est√° organizado el c√≥digo.

## ‚öíÔ∏è Mi stack actual

A continuaci√≥n, mi stack actual. Puedes ver cada plugin [en el repositorio](https://github.com/helmerdavila/portfolio/blob/ac0e7d94d48e867c30eb48784aaa349b412c91de/package.json) (antes de la actualizaci√≥n). Pero las tecnolog√≠as principales son:

- Gatsby + Typescript sobre Node 18
- Jest
- React test utils
- Eslint + Prettier

## ‚öôÔ∏è Instalaci√≥n y creando tu archivo de configuraci√≥n

Como te puedes imaginar, lo primero por hacer, es instalar Vitest

```bash
npm install -D vitest
```

Pero, si quieres seguir utilizando React Test Utils, trabajar con React y tener _coverage_ de c√≥digo, instala las siguientes librer√≠as a continuaci√≥n

```bash
npm install -D @vitejs/plugin-react @vitest/coverage-c8 jsdom
```

<aside>
üí° Si te preguntas por qu√© `@vitest/coverage-c8` , es la herramienta que utiliza Vitest por defecto, si quieres cambiar a Istanbul, sigue las instrucciones [especificadas de Vitest.](https://vitest.dev/guide/coverage.html#ignoring-code)

</aside>

### Configuraci√≥n para Typescript

Ya que vamos a trabajar con las definiciones globales para Vitest, agrega el siguiente fragmento de c√≥digo en tu archivo `tsconfig.json`

```json
{
  "compilerOptions": {
    ...
    "types": [
      "vitest/globals"
    ]
  }
}
```

### vitest.config.ts

Despu√©s de instalar las dependencias, crea un archivo `vitest.config.ts` en la ra√≠z de tu proyecto

```tsx
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './vitest-setup.ts',
    include: ['src/**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'],
    coverage: {
      reporter: ['html', 'json', 'text'],
    },
  },
});
```

Voy a explicar por qu√© agregu√© algunas opciones a la configuraci√≥n:

- La funci√≥n `react()` , dentro de la secci√≥n de plugins, agrega soporte para la sintaxis de React.
- La propiedad `globals` establece todas las funciones comunes de prueba, como globales, entre ellas `describe`, `it`, `expects` y as√≠ sucesivamente.
- `environment` como `jsdom` . Puedes comprobar cuando instalamos la biblioteca, agregar√° soporte para consultar el DOM cuando trabajamos con `react-test-utils`.
- La propiedad `setupFiles` hace referencia a `./vitest-setup.ts`. Un archivo que cubriremos en profundidad m√°s adelante.
- En la parte `include`, puede agregar una expresi√≥n regular de formatos y nombres de archivos que se observar√°n en el comando de prueba. Como puedes ver, he agregado soporte incluso a `mjs, cjs`, sintaxis de m√≥dulo para futures versiones de Javascript.
- `coverage`, donde puedes especificar los formatos de reporte de la herramienta de _coverage_

### vitest-setup.ts

Este archivo de configuraci√≥n es donde podemos especificar algunas acciones, antes de que todos los tests se ejecuten. Aqu√≠, agregu√© una conexi√≥n entre Testing Library y Vitest.

Despu√©s de cada test, limpiaremos los resultados al renderizar los componentes de React (`afterEach`).

```tsx
import { afterEach } from 'vitest';
import '@testing-library/jest-dom';
import matchers from '@testing-library/jest-dom/matchers';
import { cleanup } from '@testing-library/react';

expect.extend(matchers);

afterEach(() => {
  cleanup();
});
```

## ‚ôªÔ∏è Actualizando los Mocks

Si has hecho frecuentemente los Mocks de Jest en tu proyecto, podr√≠a demorar la migraci√≥n de tu proyecto m√°s de lo anticipado. Vitest ofrece una f√°cil compatibilidad con los mocks creados en Jest, y he aqu√≠ algunos tips que us√© (o descubr√≠) mientras estaba realizando la migraci√≥n. Siempre recomiendo [leer la documentaci√≥n oficia](https://vitest.dev/guide/mocking.html)l.

### Reemplaza jest con vi

Ejemplo: para el uso de `vi.fn()` . En el siguiente archivo en mi portafolio, `__mocks__/gatsby-background-image.ts`, observa como realizo el reemplazo.

```diff

import React from 'react';
+ import { vi } from 'vitest';

- export default jest.fn().mockImplementation(({ children }) => React.createElement('div', null, children));
+ export default vi.fn().mockImplementation(({ children }) => React.createElement('div', null, children));
```

### Reemplaza requireActual con importActual

Usaremos de ejemplo mi archivo `__mocks__/gatsby.ts` . Adem√°s comprueba el uso de `await` .

```diff
import React from 'react';
- const gatsby = jest.requireActual('gatsby');
+ import { vi } from 'vitest';

+ const gatsby = await vi.importActual<object>('gatsby');

const mockImage = ({ imgClassName, ...props }) => React.createElement('img', { ...props, className: imgClassName });

module.exports = {
  ...gatsby,
-  graphql: jest.fn(),
-  Link: jest.fn().mockImplementation(mockLink),
-  StaticQuery: jest.fn(),
-  useStaticQuery: jest.fn(),
-  GatsbyImage: jest.fn().mockImplementation(mockImage),
-  StaticImage: jest.fn().mockImplementation(mockImage),
+  graphql: vi.fn(),
+  Link: vi.fn().mockImplementation(mockLink),
+  StaticQuery: vi.fn(),
+  useStaticQuery: vi.fn(),
+  GatsbyImage: vi.fn().mockImplementation(mockImage),
+  StaticImage: vi.fn().mockImplementation(mockImage),
};
```

### Antes de usar cualquier Mock en los tests, llama al Mock

¬øQu√© pasar√≠a si quisiera usar mi archivo mostrado arriba? Imp√≥rtalo antes de los tests, o de acuerdo a los casos que est√©s codificando.

```tsx
vi.mock('gatsby');
```

Si necesitas usar m√∫ltiples mocks, a continuaci√≥n una demostraci√≥n.

```tsx
vi.mock('gatsby');
vi.mock('gatsby-plugin-image');
vi.mock('react-slick');
```

### Creando un mock antes de cada test

¬øQu√≠eres tener autocompletado para mocks escritos en Typescript s√≥lo para un archivo? Observa como agrego soporte de autocompletado.

El autocompletado comenzar√° al acabar de escribir `(useStaticQuery as Mock)`.

```tsx
import { loadTranslations } from '../../utils/mockresponses';
import type { Mock } from 'vitest';

beforeEach(() => {
  (useStaticQuery as Mock).mockReturnValueOnce(loadTranslations);
});
```

### ¬øCambiando spyes?, usa vi.spyOn

```diff
- const getItemMock = jest.spyOn(window.localStorage.__proto__, 'getItem');
+ const getItemMock = vi.spyOn(window.localStorage.__proto__, 'getItem');
```

## ‚è¨ Actualizando comandos de NPM

Los comandos Vitest corren por defecto en modo `watch`. Utiliza la opci√≥n `run` para evitar d√©jarlos en ejecuci√≥n.

Yo cre√© comandos alternos que puedo ejecutar en Github Actions. Comprueba mi `package.json` .

```json
{
	"scripts": {
		...
    "test": "vitest",
    "test:ci": "vitest run",
    "test:cov": "vitest run --coverage"
  },
}
```

## üî® Github Actions

Por mala suerte, [el plugin que us√© para crear los reportes](https://github.com/ArtiomTr/jest-coverage-report-action) de mi _coverage_ de c√≥digo no es compatible con Vitest. Espero en el futuro encrontrar uno similar, ya que no tengo el tiempo de hacer un _fork_ y modificarlo.

En Github Actions, as√≠ es como aun sigo corriendo y validando mis tests.

```yaml
name: Tests
on:
  pull_request:
    branches:
      - main
jobs:
  coverage:
    name: Coverage
    runs-on: ubuntu-latest
    env:
      NODE_OPTIONS: --max-old-space-size=4096
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version-file: '.nvmrc'
          cache: npm
      - name: Installing dependencies
        run: npm ci
      - name: Running tests
        run: npm run test:cov
```

## üóëÔ∏è Remueve las referencias a Jest

Para mi portafolio, ya no necesitaba las siguientes librer√≠as:

- `@types/jest`
- `babel-jest`
- `jest`
- `ts-jest`
- Adicionalmente, remov√≠ tres archivos de configuraci√≥n desde la ra√≠z de mi proyecto.

## üèéÔ∏è Corriendo tests y comparando la velocidad

Para 74 tests que tengo el d√≠a que estoy escribiendo esto, la diferencia entre Jest y Vitest es s√≥lo de 1 segundo, donde Vitest es el ganador. No se ve como mucho, pero cuando la cantidad de tus tests comienza a incrementarse, la diferencia se incrementar√°, por supuesto.

Aqu√≠ una comparaci√≥n entre Jest y Vitest corriendo la misma suite de tests.

![Primer test](./comparison_one.png)

![Segundo test](./comparison_two.png)

## ‚òëÔ∏è Conclusi√≥n

Ya que estamos escribiendo sobre dependencias de un entorno de desarrollo y un proyecto peque√±o, usar Vitest en este caso ser√° una buena idea. Aumentos en la velocidad de ejecuci√≥n de tests, configuraci√≥n de Typescript por defecto y soporte para Jetbrains y Vscode.

Sin embargo, si tienes un proyecto grande en Jest, que depende de una gran lista de dependencias. Mi respuesta es NO, no necesitas moverte a Vitest, el esfuerzo podr√≠a ser el doble o el triple m√°s de lo que hayas pensado. Considera peque√±os avances, comienza a mover tests peque√±os que no causen riesgo, _sprint_ por _sprint_, en _milestones_.

Puedes comprobar mi PR de mi portafolio [en este enlace.](https://github.com/helmerdavila/portfolio/pull/96)

## üîó Enlaces externos

- [https://www.lekoarts.de/garden/testing-gatsby-s-head-api-with-vitest-and-playwright](https://www.lekoarts.de/garden/testing-gatsby-s-head-api-with-vitest-and-playwright)
- [https://www.robinwieruch.de/vitest-react-testing-library/](https://www.robinwieruch.de/vitest-react-testing-library/)
