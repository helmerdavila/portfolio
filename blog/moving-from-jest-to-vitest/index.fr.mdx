---
title: Jâ€™ai changÃ© tous mes tests de Jest Ã  Vitest en moins de 3 heures
description: J'avais lu des nombreux avantages de Vitest, tels que la vitesse, la facilitÃ© de migration depuis Jest et lâ€™implÃ©mentation dâ€™une configuration simple pour intÃ©grer Typescript.
date: 2023-02-14
published: true
image: ../../src/images/blog/moved-from-jest.png
imageAlt: 'Depuis Jest Ã  Vitest'
tags: ['react', 'jest', 'vitest', 'testing', 'typescript', 'gatsby']
---

# Jâ€™ai changÃ© tous mes tests de Jest Ã  Vitest en moins de 3 heures

## ğŸ¤” Et pourquoi?

J'avais lu des nombreux avantages de Vitest, tels que la vitesse, la facilitÃ© de migration depuis Jest et lâ€™implÃ©mentation dâ€™une configuration simple pour intÃ©grer Typescript.

Alors, j'ai calculÃ© une migration de ma pile de tests en environ 6 heures et cela m'a pris seulement 3 heures. Pour Ãªtre honnÃªte, cela aurait pu Ãªtre encore moins, tout dÃ©pend de votre vitesse Ã  Ã©crire du code, de la complexitÃ© du projet et de la faÃ§on dont le code est organisÃ©.

## âš’ï¸ Mon stack actuel

Ensuite, mon stack actuel. Tu peux voir chaque plugin dans [mon dÃ©pÃ´t](https://github.com/helmerdavila/portfolio/blob/ac0e7d94d48e867c30eb48784aaa349b412c91de/package.json) (avant de la mise Ã  jour). Les technologies principales sont:

- Gatsby + Typescript sur Node 18
- Jest
- React test utils
- Eslint + Prettier

## âš™ï¸ Installer et crÃ©er ton fichier de configuration

La premiÃ¨re chose Ã  faire, câ€™est installer Vitest

```bash
npm install -D vitest
```

Mais, si tu veux continuer Ã  utiliser React Test Utils, travailler avec React et avoir un _coverage_ de code, installe les plugiciels suivants.

```bash
npm install -D @vitejs/plugin-react @vitest/coverage-c8 jsdom
```

<aside>
ğŸ’¡ Si tu demandes pourquoi on utilise `@vitest/coverage-c8` , câ€™est lâ€™outil que Vitest utilise par dÃ©faut, si tu veux le changer Ã  Istanbul, [suivre les Ã©tapes suivantes ici](https://vitest.dev/guide/coverage.html#ignoring-code).

</aside>

### Configuration pour Typescript

Puisquâ€™on va travailler sur les dÃ©finitions globales pour Vitest, ajoute ce code suivant dans ton fichier `tsconfig.json`

```json
{
  "compilerOptions": {
    ...
    "types": [
      "vitest/globals"
    ]
  }
}
```

### vitest.config.ts

AprÃ¨s lâ€™installation des plugiciels, crÃ©e un fichier `vitest.config.ts` Ã  la racine de ton projet.

```tsx
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './vitest-setup.ts',
    include: ['src/**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'],
    coverage: {
      reporter: ['html', 'json', 'text'],
    },
  },
});
```

Je vais expliquer pourquoi jâ€™ai ajoutÃ© des options Ã  la configuration:

- La fonctionne `react()`, dans la section des plugiciels, ajoute de support pour la syntaxe de React.
- La propriÃ©tÃ© `globals` Ã©tablit toutes les fonctionnes communes de test, parmi eux, `describe`, `it`, `expects` et comme Ã§a.
- `environment` comment `jsdom` . Lorsquâ€™on a installÃ© le plugiciel, il ajoute de support pour faire des consultations sur le DOM quand on travaille avec `react-test-utils`.
- La proprietÃ© `setupFiles` fait allusion Ã  `./vitest-setup.ts` . Un fichier quâ€™on abordera plus en profondeur plus tard.
- Dans `include`, tu peux ajouter une expression rÃ©guliÃ¨re de formats et noms de fichiers qui sâ€™observent avec la commande de test. Jâ€™ai ajoutÃ© de support aussi pour `mjs, cjs`, les syntaxes de modules pour versions futures de Javascript.
- `coverage`, dont tu peux spÃ©cifier le format du rapport pour lâ€™outil de _coverage._

### vitest-setup.ts

Ce fichier de configuration est lâ€™endroit oÃ¹ on peut spÃ©cifier quelques actions, avant dâ€™exÃ©cuter tous les tests. Ceci, jâ€™ai ajoutÃ© une connexion entre Testing Library et Vitest.

AprÃ¨s chaque test, nous nettoierons les rÃ©sultats au rendre les composants de React (`afterEach`).

```tsx
import { afterEach } from 'vitest';
import '@testing-library/jest-dom';
import matchers from '@testing-library/jest-dom/matchers';
import { cleanup } from '@testing-library/react';

expect.extend(matchers);

afterEach(() => {
  cleanup();
});
```

## â™»ï¸ Mise Ã  jour des Mocks

FrÃ©quemment, si tu fais des Mocks de Jest dans ton projet, Ã§a peut causer retards Ã  la migration. Vitest offre une compatibilitÃ© facile avec les mocks crÃ©es en Jest. Ensuite, quelques astuces que jâ€™ai utilisÃ©es (ou dÃ©couvertes) pendant la migration. Toujours je recommande de [lire la documentation officielle.](https://vitest.dev/guide/mocking.html)

### Replace `jest` avec `vi`

Par exemple: lâ€™usage de `vi.fn()` . Pour ce fichier dans mon portfolio, `__mocks__/gatsby-background-image.ts`, observe comment je faire le replace.

```diff

import React from 'react';
+ import { vi } from 'vitest';

- export default jest.fn().mockImplementation(({ children }) => React.createElement('div', null, children));
+ export default vi.fn().mockImplementation(({ children }) => React.createElement('div', null, children));
```

### Replace `requireActual` avec `importActual`

On utilise par exemple mon fichier `__mocks__/gatsby.ts` . De plus, vÃ©rifie lâ€™usage de `await`

```diff
import React from 'react';
- const gatsby = jest.requireActual('gatsby');
+ import { vi } from 'vitest';

+ const gatsby = await vi.importActual<object>('gatsby');

const mockImage = ({ imgClassName, ...props }) => React.createElement('img', { ...props, className: imgClassName });

module.exports = {
  ...gatsby,
-  graphql: jest.fn(),
-  Link: jest.fn().mockImplementation(mockLink),
-  StaticQuery: jest.fn(),
-  useStaticQuery: jest.fn(),
-  GatsbyImage: jest.fn().mockImplementation(mockImage),
-  StaticImage: jest.fn().mockImplementation(mockImage),
+  graphql: vi.fn(),
+  Link: vi.fn().mockImplementation(mockLink),
+  StaticQuery: vi.fn(),
+  useStaticQuery: vi.fn(),
+  GatsbyImage: vi.fn().mockImplementation(mockImage),
+  StaticImage: vi.fn().mockImplementation(mockImage),
};
```

### Avant utiliser un Mock aux tests, appelle le Mock

Et si je voulais utiliser mon fichier prÃ©sentÃ© ci-dessus? Importe-le avant les tests, ou selon les cas que tu codes.

```tsx
vi.mock('gatsby');
```

Si tu as besoin de mocks multiples, ensuite une dÃ©mo.

```tsx
vi.mock('gatsby');
vi.mock('gatsby-plugin-image');
vi.mock('react-slick');
```

### CrÃ©er un mock avant chaque test

Veux-tu avoir lâ€™autocomplÃ©tion pour les mocks Ã©crits en Typescript seulement pour un fichier? Regarde comment je lâ€™ai ajoutÃ©.

Lâ€™autocomplÃ©tion commencera lorsquâ€™on finit dâ€™Ã©crire `(useStaticQuery as Mock)` .

```tsx
import { loadTranslations } from '../../utils/mockresponses';
import type { Mock } from 'vitest';

beforeEach(() => {
  (useStaticQuery as Mock).mockReturnValueOnce(loadTranslations);
});
```

### Souhaites de changer spyes?, utilise `vi.spyOn`

```diff
- const getItemMock = jest.spyOn(window.localStorage.__proto__, 'getItem');
+ const getItemMock = vi.spyOn(window.localStorage.__proto__, 'getItem');
```

## â¬ Mise Ã  jour des commandes NPM

Les commandes Vitest sâ€™exÃ©cutent par dÃ©faut en mode `watch`. Utilise lâ€™option `run` pour Ã©viter de les laisser en cours dâ€™exÃ©cution.

Jâ€™ai crÃ©Ã© des commandes alternatives que je peux employer dans Github Actions. Regarde mon `package.json` .

```json
{
	"scripts": {
		...
    "test": "vitest",
    "test:ci": "vitest run",
    "test:cov": "vitest run --coverage"
  },
}
```

## ğŸ”¨ Github Actions

Malheureusement, [le plugiciel que jâ€™utilise pour crÃ©er les rapports](https://github.com/ArtiomTr/jest-coverage-report-action) de mon coverage de code nâ€™est pas compatible avec Vitest. Jâ€™espÃ¨re en trouver un similaire Ã  lâ€™avenir, car jâ€™ai pas de temps de faire un fork et de le modifier.

Sur Github Actions, câ€™est ainsi comment jâ€™exÃ©cute et valide toujours mes tests.

```yaml
name: Tests
on:
  pull_request:
    branches:
      - main
jobs:
  coverage:
    name: Coverage
    runs-on: ubuntu-latest
    env:
      NODE_OPTIONS: --max-old-space-size=4096
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version-file: '.nvmrc'
          cache: npm
      - name: Installing dependencies
        run: npm ci
      - name: Running tests
        run: npm run test:cov
```

## ğŸ—‘ï¸ Retire les rÃ©fÃ©rences de Jest

Pour mon portfolio, je nâ€™avais plus besoin des plugiciels:

- `@types/jest`
- `babel-jest`
- `jest`
- `ts-jest`
- De plus, jâ€™ai supprimÃ© trois fichiers de configuration Ã  la racine de mon projet.

## ğŸï¸ ExÃ©cuter des tests et comparaisons de vitesse

Pour 74 que jâ€™ai le jour oÃ¹ jâ€™Ã©cris ceci, la diffÃ©rence entre Jest et Vitest nâ€™est que de 1 seconde, oÃ¹ Vitest est le gagnant. Cela peut donner lâ€™impression qui est peu, mais quand la quantitÃ© des tests commencera Ã  augmenter, la diffÃ©rence augmentera, bien sÃ»r.

Voici une comparaison entre Jest et Vitest en exÃ©cutant la mÃªme suite de tests.

## â˜‘ï¸ Conclusion

Puisque jâ€™Ã©cris sur les dÃ©pendances d'un environnement de dÃ©veloppement et d'un petit projet, utiliser Vitest dans ce cas sera une bonne idÃ©e. Lâ€™augmentation de la vitesse d'exÃ©cution des tests, de la configuration Typescript par dÃ©faut et du support de Jetbrains et Vscode.

Cependant, si vous avez un grand projet dans Jest, cela dÃ©pend d'une longue liste de dÃ©pendances. Ma rÃ©ponse est NON, tu nâ€™as pas besoin de migrer Ã  Vitest, l'effort pourrait Ãªtre le double ou le triple de ce que tu penses. Envisage de petites avancÃ©es, commence Ã  dÃ©placer de petits tests qui ne causent pas de risque, _sprint_ par _sprint_, en _milestones_.

Tu peux consulter mon PR de mon portefeuille [dans ce lien.](https://github.com/helmerdavila/portfolio/pull/96)
