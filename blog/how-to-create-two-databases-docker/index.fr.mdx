---
title: 'Docker MySQL: Comment cre√©r deux bases de donn√©es dans un conteneur'
description: Je n‚Äôai pas voulu contaminer ma base de donn√©es dans Docker avec plusieurs faux noms ou du contenu de Lorem Ipsum
date: 2023-03-26
image: ../../src/images/blog/containers-many.jpg
imageAlt: Photo by Timelab on Unsplash
published: true
tags: ['docker', 'mysql', 'database', 'docker-compose']
---

# Docker MySQL: Comment cre√©r deux bases de donn√©es dans un conteneur

## ü§î Pourquoi?

J'en √©tais fatigu√©.

Je n‚Äôai pas voulu contaminer ma base de donn√©es dans Docker avec plusieurs faux noms ou du contenu de Lorem Ipsum. Parce que lorsque je veux afficher tous les enregistrements ou des photos dans l'application actuelle, je veux les originaux pour la pr√©sentation au client.

De plus, j'ai voulu une base de donn√©es additionnelle, o√π si les migrations √©chouent, je peux retourner √† la derni√®re version facilement, ou la d√©truire et la recr√©er sans ex√©cuter les seeders ou utiliser une copie de sauvegarde avec des donn√©es presque r√©elles.

De nombreux frameworks ont une approche diff√©rente pour le faire, comme l'ex√©cution des tests dans les transactions, la vidange des donn√©es, etc.

Mais je ne veux pas apprendre d'une autre fa√ßon pour le faire.

J'ai trouv√© une m√©thode diff√©rente.

Qu'arriverait-il si nous ajoutions d'autres bases de donn√©es dans le conteneur ? Mieux encore, de mani√®re automatique.

## üî® Comment?

Pour d√©montrer que je n'utilise pas l'IA pour g√©n√©rer des tutoriels s√©rieux dans mes posts, je vais utiliser `potato` (pomme de terre) comme nom de projet dans ce tutoriel.

Tout d'abord, cr√©e un dossier o√π tu veux sauvegarder les **scripts**. Pour ce tutoriel, on va l'appeler `dockerdb_init`. Ensuite, cr√©e un fichier appel√© `create_test_database.sql` avec le contenu suivant :

```sql
CREATE DATABASE IF NOT EXISTS `potato_db_test`;
GRANT ALL ON `potato_db_test`.* TO 'potato_db_user'@'%'
```

> Docker cr√©e simplement une base de donn√©es en utilisant les variables d'environnement fournies. Puisque le projet utilise une base de donn√©es de test, nous allons ajouter le suffixe "test".

Si tu utilises un fichier `docker-compose.yml`, c'est la sp√©cification pour le conteneur.

```yaml
db:
  container_name: potato_db
  image: 'mysql:8.0'
  volumes:
    - './dockerdb:/var/lib/mysql'
    - './dockerdb_init:/docker-entrypoint-initdb.d'
  env_file:
    - .env
  ports:
    - '3306:3306'
```

Pour la raison que je veux garder mes variables d'environnement dans un fichier s√©par√©, tu peux les mettre dans ton fichier `.env`:

```bash
MYSQL_ROOT_PASSWORD=rootpassword
MYSQL_DATABASE=potato_db
MYSQL_USER=potato_db_user
MYSQL_PASSWORD=potato_db_pass
```

La premi√®re fois que tu ex√©cutes le conteneur, le script s'ex√©cutera et tu auras d√©sormais deux bases de donn√©es : `potato_db` et `potato_db_test`.
